---
layout:     post
title:      よくわかるC言語
subtitle:   一篇文章教你速成C语言
date:       2021-03-31
author:     千夜chiya
header-img: img/2021/03/31/01/title.jpg
catalog: true
tags:
    - C
---

![](http://panzhifei.fun/img/2021/03/31/01/title_c.jpg)

この連載に目を止め，「読んでみようか」と思ってくれた皆さんは，これまで，どんなプログラム言語の経験があるでしょうか？ 「JavaScriptなどのWeb系のスクリプト言語はよく使う」，「Visual BasicやJavaでアプリケーションを作っているのだけど，基本を確認したくて…」，あるいは「連載1回目だし，これからプログラミングを学びたい」など，いろいろな方がいらっしゃると思います。

　本連載は，「C言語」というプログラミング言語の“定番”を通して，あらゆるプログラミングに共通する基礎となる部分を，じっくり解説していきます。初心者の方はもちろん，プログラミング経験のある方も自分の知識を再確認するのにきっと役立つと思います。

<center>☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆</center>
<center>☆　　　　　タイトル　　　　　☆</center>
<center>☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆</center>

- [第1回　もう一度，C言語から始めよう　](#title1)
- [第2回　変数の性質を理解しよう　](#title2)
- [第3回　制御構文がわかればプログラムの「流れ」がわかる　](#title3)
- [第4回　変数のスコープをアドレスを使って理解する](#title4)　
- [第5回　配列を理解してアルゴリズムを考える　](#title5)
- [第6回　ポインタを理解して文字列を扱う　](#title6)
- [第7回　再帰処理と参照渡し（モドキ）のメリット・デメリット　](#title7)
- [第8回　構造体でデータをスッキリと扱う　](#title8)
- [第9回　動的なメモリーの確保とリスト処理　](#title9)
- [第10回　定番の関数を覚えればファイル処理などカンタンだ　](#title10)
- [第11回　ランダム・アクセスとバイナリ・ファイルの扱いを学ぶ　](#title111)
- [第12回　構造体に手足を付ければ，それがクラスだ　](#title12)
- [コメント](#title13)

# <span id="title1">第1回　もう一度，C言語から始めよう</span>

## コンピュータはマシン語しか理解しない

　皆さんは，そもそもコンピュータは何語で動いているのかわかりますか？ 日本人にとっての母国語が日本語で，英国人にとってのそれが英語であるように，コンピュータにとっての母国語は機械語（マシン語）です＊1。人間は，必要に迫られれば学習し，カタコトでも他国語を話せるようになりますが，コンピュータはちっとも自発的に学習してくれません。何年たっても，マイクロプロセサが直接に解釈・実行できる言語はマシン語だけです（多くの日本人が，中学からずーっと英語を勉強しているわりに，英語を話せないという事実はまあ，それはおいといて…）。

　マシン語というと，何か意味のある言葉のようなイメージがしますが，デジタル機器であるコンピュータの中では，プログラムも含め，あらゆる情報が2進数で表現されています。ですから，マシン語は人間の目には単なる数字の羅列にしか映りません。例えばこんな感じです。

```
　4D 5A 44 01 12 00 12 00 20 00 FF …
```

マシン語プログラムを16進数＊2で表示させると，上記のように数字が並んでいるだけなのです。

　かつて，「コンパイラ」や「インタプリタ」という名前の便利な道具が存在しない時代がありました。そのころは，人間がこのマシン語でプログラムを記述していたのです。「4D5Aと書くと×××が○○○になるから，次は4401で△△△して…」と人間にとっては意味を見出せない数字の羅列でプログラムを作っていた――今，考えるとぞっとする作業ですね。

　そこで，人間にわかりやすい文字で書いたものをマシン語に変換（翻訳）するプログラムが開発されました。それが「アセンブリ言語」です。アセンブリ言語では「ニーモニック」という英単語を略式化したような記号でプログラムを記述します。例えば以下のような感じです。

```x86asm
　push ebp

　mov ebp,esp

　xor edx,edx

　mov eax,1
　…
```

このニーモニック・コードで記述されたプログラムを，「アセンブラ」という別のプログラムがマシン語に翻訳するのです。アセンブラは，ニーモニック・コードをマシン語に1対1で翻訳するプログラムです。ADD（加算），CMP（比較），DIV（除算），INC（＋1する），DEC（－1する），JMP（無条件ジャンプ），MOV（データの転送）――といった命令が用意されています。

　アセンブリ言語を使えば，数字の羅列に比べてだいぶプログラムを読み書きやすくはなりました。しかし，しょせんアセンブリ言語も，基本的にはマシン語と1対1で対応しているに過ぎません。複雑なロジックを書くには面倒だということは想像がつくでしょう。わかりやすくなったけど，プログラミングはやっぱり大変な作業であるという状態ですね。

## C言語はプログラマの共通語

　やがて，大規模なプログラムを，もっと効率よく，もっと簡単に作成できないかと，より自然言語＊3に近い言葉でプログラムを記述するためのプログラミング言語（高級言語）の開発が始まりました。科学技術計算に向くFORTRAN，プログラミング初心者に適したBASIC，小数の計算が正確で事務処理に向くCOBOL，明確な文法を持つPascal――など1950年代ごろから，様々な高級言語が生まれました。

　そして1970年ごろ，これから本連載で皆さんが学ぶC言語が登場したのです。C言語は当初，UNIXというOSを開発するために作られました。しかしC言語が備える機能が強力だったため，UNIX上で動作するプログラムの開発や，Windowsにも使われていくようになりました。現在，Windows用のソフトウエア開発で，C言語が一番使われているというわけではありません。それでも，現在利用されている多くのプログラミング言語は，C言語の影響を少なからず受けています。

　C言語をオブジェクト指向化したC++や .NET対応のC#は当然C言語の流れをくんでいます。Javaもそうです。Webアプリケーションで使われているPerl，PHP（PHP：Hypertext Preprocessor），JavaScriptなどもC言語の影響を強く受けています。

　つまりC言語をマスターすれば，プログラミングに必要な基礎が身に付くとともに，現在注目を浴びている言語を学ぶ足がかりができるのです。今のC言語は，プログラミングを深く理解するうえでの共通言語に成っているといえなくもないでしょう。

## C言語はコンパイラを使う

　さて，高級言語には，書いたプログラムをマシン語に翻訳するのに大きく2種類の方法，インタプリタとコンパイラがあります（図1）。図1上のインタプリタでは，プログラム実行時に1行ずつ翻訳を行います。翻訳－実行を1ステップ（1行）ごとに繰り返すわけです。実行するたびに翻訳する手間がありますから，処理速度はあまり速くはありません。でも，プログラムのバグ＊4を見つけて修正したら，すぐに再実行できるという利点があります。短いプログラムを作成する場合や，プログラミングの学習に適しています。

![](http://panzhifei.fun/img/2021/03/31/01/zu01.jpg)
*図1●インタプリタとコンパイラ*

一方，図1下のコンパイラは，マシン語にプログラムを翻訳して，実行可能なファイルを作成します。プログラムに文法上の間違いがあった場合は，コンパイラがコンパイル・エラーとして出力するので，エラー・メッセージの内容を分析してプログラム上のミスを修正し，再度コンパイルしてプログラムを作っていきます。実行速度は翻訳の手間が必要ないぶんだけ，一般にインタプリタに比べて高速です。C言語は，こちらのコンパイラ方式を採用しています。

　ちなみにJavaや .NETに対応したプログラミング言語（C#，Visual Basic .NETなど）も，コンパイラを利用します。ただし，これらのコンパイラは特定のOSに依存するマシン語を作成するのではなく，代わりに「中間コード」というものを出力します。出力された中間コードは，Javaなら，Java VM＊5というJavaプログラム専用の実行環境上で，.NETなら .NET Framework上＊6でマシン語に翻訳され実行されます。実行環境がOSの違いを吸収してくれるので，同じプログラムが別の種類のコンピュータ上でも動作できる仕組みなわけです。

**なにはともあれ**

## コンパイラをインストールする

　プログラミング言語の学習で一番大事なことは，実際に“自分の手を使って”プログラムを作成し，コンパイル・実行してみることです。読むだけではだめです。本連載でも，皆さんが実際に手を動かしながら学んでいけるようにしていきますので，どうぞ試してみてください。

　本連載で利用するC言語のコンパイラは「Borland C++ Compiler 5.5」です。ボーランドが[Webサイト](http://www.borland.co.jp/cppbuilder/freecompiler/)で無償公開しています。このコンパイラを使えば，Windows 95/98/MeのMS-DOSプロンプトや，Windows XPなどのコマンドプロンプト上で，C言語あるいはC++言語で記述したソース・プログラムをコンパイルできます。

まずはインストールしましょう。今回はWindows XPにインストールする手順を説明しますが，Windows 2000や98/Meでも利用できます[＊7](#jump7)。インストール後に必要な設定がありますので，読み飛ばさずにゆっくりお付き合いください。

　ダウンロードした「freecommandlinetools2.exe」をダブルクリックすると，インストーラが起動します。使用許諾契約のダイアログが表示されますので，同意して，インストールするフォルダを選択してください。デフォルトはc:\borland\bcc55です。特に理由がない限り，そのままがよいでしょう。インストールが終わると，c:\borland\bcc55にいろいろなファイルが作成されます。「readme.txt」というファイルに必要な設定が書いてありますので，メモ帳などのエディタで開いて読んでください。

　readme.txtの「2.のa.」という欄に「既存のパスに "c:\Borland\Bcc55\bin" を追加します」とあります。パス（path）という言葉がはじめてだと，目的が理解しにくいと思いますので，簡単に解説しておきましょう。

　コマンドプロンプトを起動して，カーソルが点滅している部分に次のコードを入力してEnterキーを押してください。

　**cd \borland\bcc55\bin**

cdとは，ユーザーが作業を行うフォルダ（カレント・ディレクトリ）を移動する，MS-DOSのcd（change directory）コマンドのことです。コマンドプロンプトには「C:\cd \borland\bcc55\Bin＞」という文字が出て，カーソルが点滅していると思います。つまり，カレントディレクトリが，c:\borland\bcc55\binに移動したわけです。

　実はBorland C++ Compiler 5.5の本体であるコンパイラ・プログラムは，このフォルダの中にある「bcc32.exe」ファイルです。ですからここで，

　**bcc32**

と入力すると，コンパイラ・プログラムを起動できます。でも，コンパイラ・プログラムを起動するために，いちいちc:\borland\bcc55\binにカレント・ディレクトリを移動するのは面倒ですよね。フォルダを新たに作って，そこにプログラム・ファイルを保存したいと思うでしょう。

　そこでパスの設定が必要になります。というのも，c:\borland\bcc55\bin以外のほかのフォルダがカレント・ディレクトリになっている場合は，bcc32.exeがどこにあるか，Windowsが理解できなくなってしまうからです。Windowsには，「c:\Borland\Bcc55\binにbcc32.exeがあるよ」と教えてやらなければなりません。そうしないと「bcc32.exeが見つからないよ」というエラーになります。

　パスを設定するには，Windows 2000/XPの場合，マイコンピュータを右クリックし，プロパティを選びます。詳細設定（Windows 2000の場合，詳細）タブを選び，環境変数ボタンを押します。続いてシステム環境変数のPathを選び，編集ボタンを押します。変数値（Windows 2000の場合，値）の末尾に，すでに入力されている文字列に続けて

　**;C:\borland\bcc55\Bin**

と入力してください。これでOKボタンを押して登録すれば，どこのフォルダがカレントになっていても，bcc32.exeを実行できるようになります。なお，この変更は次にコマンドプロンプトを起動したときに有効になります。

　もう一つやっておくことがあります。readme.txtの「2のbとc」に，「bcc32.cfgとilink32.cfgというファイルを作るように」と書いてあります。bcc32.cfgファイルの目的は，コンパイラに「インクルード・ファイル」と「ライブラリ・ファイル」というファイル群の存在する場所を指定することです。

　bcc32.cfgを作らないと，コンパイルできないというわけではないのですが，作らない場合はコンパイルを行うたびに，インクルード・ファイルとライブラリ・ファイルの場所を指定しなければなりません。bcc32.cfgという設定ファイルを作っておけば，コンパイルが容易になるのです。

　readme.txtの

　**-I"c:\Borland\Bcc55\include"**

　**-L"c:\Borland\Bcc55\lib"**
という2行をコピーして，テキスト・エディタの別のウィンドウにペーストします。そしてファイル名を「bcc32.cfg」として，c:\borland\bcc55\Binフォルダに保存します。

　同様に

　**-L"c:\Borland\Bcc55\lib"**

の1行も，コピーアンドペーストして，ilink32.cfgというファイル名で同じフォルダに作成してください。

　それから，c:\borlandの中に，ソース・プログラムを入れておく場所として，srcなどの名前でサブ・フォルダを作っておくとよいでしょう＊8。これで準備はOKです。

## 最初のプログラムを作って実行する

　さて，いよいよC言語のプログラムを書いてみましょう。

　ソース・プログラムはエディタと呼ばれるソフトウエアを使って書きます。いつもお使いのエディタがあれば，それをお使いください。何もなければ，メモ帳でも構わないのですが，インターネットで「エディタ　フリー」などのキーワードで検索してC言語のソース・プログラム編集に適したものをダウンロードされるとよいでしょう。

　それでは最初のプログラムを書いて，コンパイル/実行してみましょう（リスト1）。画面にHelloと表示するだけのプログラムです。c:\borland\srcにエディタで作成して「hello.c」というファイル名で保存します。C言語のソース・プログラムだから拡張子はcになります。

![](http://panzhifei.fun/img/2021/03/31/01/list01.jpg)
*リスト1● 最初のC言語のプログラム。画面に 「Hello」と表示する*

ここでコマンドプロンプトを起動し，カレント・ディレクトリをc:\borland\srcに移動して（前述のcdコマンドを使って），

　**bcc32 hello.c**

と入力してコンパイルします（図2）。コンパイル・エラーがなければ，hello.exeという実行ファイルが作成されます。

![](http://panzhifei.fun/img/2021/03/31/01/zu02.jpg)
*図2●リスト1のプログラム（hello.c）をコンパイルする様子*

　作成したプログラムを実行するには，

　**hello**

と入力します（**図3**）。画面にHelloと表示されました。

![](http://panzhifei.fun/img/2021/03/31/01/zu03.jpg)
*図3●コンパイルしたhello.cを実行した*

　ここで一つ，覚えておいていただきたいことがあります。実はコンパイル処理だけで実行ファイルができるのではありません。自分の書いたソース・プログラムをコンパイラがオブジェクト・ファイル（マシン語に翻訳されている）として出力します。そのオブジェクト・ファイルを，リンカーというプログラムが，標準ライブラリとリンク（結合）して，実行ファイル（この場合ならhello.exe）を作成します（**図4**）。Borland C++ Compilerでは，オプションで「コンパイルのみ」を指定しない限り，エラーがなければ，自動的にリンク処理が呼び出されます。bcc32.cfg ファイルに

**-L"c:\Borland\Bcc55\lib"**

と記述したのは，標準ライブラリの場所を示すためだったのです。

![](http://panzhifei.fun/img/2021/03/31/01/zu04.jpg)
*図4●オブジェクト・ファイルと標準ライブラリ・ファイルをリンカーがリンクして実行ファイルを生成する*

## プログラムを読んでみる

　連載1回目ですから，あまりややこしい話はしたくないのですが，ソース・プログラムの説明をしないわけにはいかないので，少し我慢してお付き合いください。

　C言語は「構造型言語」と呼ばれます。アセンブリ言語のように，コードをズラズラと続くような書き方はしません。プログラムは一つ以上の複数の関数で構成されます。リスト1をもう一度見てください。

　まず，mainという名前の関数(2)が必要です。関数の始めと終わりは(3)と(6)のように「{」と「}」で示します。プログラムはmain関数の1行目から実行されます。このサンプルでは(4)のprintf関数から実行されます。printf関数は「標準ライブラリ」に登録されている関数です。標準ライブラリは，画面への表示のように，プログラマの誰もがよく使う処理を集めた道具箱のようなものです。

　printf関数は，ダブルクォーテーション（"）に囲まれた文字列を出力します。リンカーが標準ライブラリの一部を，自分の作ったプログラムにくっつけてくれるので，printf関数を使って画面に文字列を出力できるのです。

　標準ライブラリとして，多くの関数が用意されていることがアセンブリ言語に比べて，プログラミングの効率が良い理由の一つです。C言語では，用意されている（あるいは自分で作った）関数を組み合わせて，プログラムを構成していくわけです。

　ソースコードの1行はセミコロン（;）で終わります。関数は，中学校の数学の授業で習った関数と同じで，値を返します。(5)のreturn文が0という値を返しています。

　(1)の「#」ではじまる命令はプリプロセッサ命令と呼ばれ，Cコンパイラがソース・プログラムを解釈する前に実行されます。#includeは＜と＞の中に書かれている拡張子.hのヘッダー・ファイルをインクルード（取り込み）します。stdio.hに書いてある内容が，そのまま自分のプログラムの中に展開されるのです。bcc32.cfgに記述した

　**-I"c\Borland**

　**\Bcc55\include"**

は，このヘッダー・ファイルのありかを示していたのです。
　これで，プログラムを作成し，コンパイル，実行するまでの手順がおわかりいただけたと思います。次に，ちょっと面白いことをしてみましょう。

## アセンブリ・コードと比べてみる

　Cコンパイラの多くは，アセンブリ・リストを出力する機能を備えています。C言語で書いたソースコードをアセンブリ言語のコードとして出力することができるのです。例えばBorland C++ Compilerでは，次のようにオプションに「-S」を指定すると，アセンブリ・コードを出力してくれます。

　**bcc32 -S hello.c**

なお，オプションの指定では，大文字と小文字が区別されますので注意してください。

　実際に実行してみると，この例では，hello.asmというファイルが作成されます。一部を抜粋してみました（リスト2）。構成がわかりにくいかもしれませんが，セミコロンに続くコードが元のCのコードで，それ以外の部分がアセンブリ言語のコードです。

![](http://panzhifei.fun/img/2021/03/31/01/list02.jpg)
*リスト2●hello.cから生成したアセンブリ・コード*

なにやらズラズラと書いてありますが，コードの内容がわからなくても大丈夫です。冒頭で説明したように，ニーモニック・コードとマシン語は1対1で対応します。しかし，Cのコードとアセンブリ言語のコードは1対1にはなっていませんね。C言語のコード1行から，複数行のアセンブリ・コードが出力されています。

　ソースコード1行から，複数行のアセンブリ・コード，つまりマシン語が出力されるのですから，C言語はアセンブリ言語よりもプログラムの開発効率が高いということができます。「C言語って，マシン語やアセンブラでプログラムを作るよりも便利なんだ」――そう感じてもらえれば，連載第1回の目標は達成です。

# <span id="title2">第2回　変数の性質を理解しよう</span>

皆さん，こんにちは。この連載「よくわかるC言語」は，今回が2回目です。前回はC言語のソース・プログラムをアセンブラのコードとして出力して，Cのソースコード1行が複数のアセンブラのコードに対応していることを確認しました。なるほどC言語は“高級”な言語なのだと，感じていただけたのではないでしょうか。

　さて，皆さんがプログラミングをしていて，“こう書くとこうなるけど，その理由はわからない”という方はいらっしゃいませんか。でもあまり心配する必要はありません。なぜそうなるのかの理由がわからないのは，たぶんプログラミングがわからないのではなくて，コンピュータの動作原理などの基礎知識が不足しているだけです。今回のテーマは「変数」ですが，この“コンピュータの仕組み”に重点を置いて説明していきます。ぜひ最後まで読んでみてください。ぼんやりしていた部分がはっきりすることでしょう。

## 変数はメモリーの一部に名前を付けたもの

　では早速始めます。変数そのものを解説する前に，プログラムが扱う様々なデータを，コンピュータがどのように“記憶”するかを確認するところからお話ししましょう。

　コンピュータがデータを記憶するには，メモリーかハードディスクを利用します。メモリーは，CPUが直接アクセスできる記憶装置です。半導体素子を利用して，データを電気的に記録します。動作は高速ですが，電源を切ると内容が失われてしまいます。情報処理の用語では「主記憶装置」と呼ばれています。

　電源が切れたら消えてしまうと困るようなデータを記憶させるときには，皆さんご存じのハードディスクを利用します。フロッピ・ディスクやCD-Rなどを利用することもありますね。これらは「補助記憶装置」と呼ばれています。

　ちょっと当たり前すぎて簡単に感じられたかもしれません。ここからが大事なところです。補助記憶装置に記憶されたデータをコンピュータが利用するときには，必要なものだけを主記憶装置（メモリー）に読み込んで利用します。やみくもに読み込むだけでは，何がどのデータだかわかりにくくなってしまいます。なのでプログラミング言語からは，メモリーの一部を，自分が付けた名前で扱えるようになっています。これが変数です。

## char型の範囲が－128～127って？

　となると，変数について正しく理解しないと，目的に合った正しいプログラムを作るのは難しいですよね。変数とはどのようなものかをもう少し詳しく見ていきましょう。

　変数には「型」というものがあります。型は，その変数が(1)どのような形でデータを格納するかと，(2)一つの変数がメモリーをどれくらい必要とするかの二つを定めたものと考えてください。C言語の代表的な型と表現できる値の範囲は，表1のようになります。10年いや20年ぐらい前のことですが，筆者が初めてこのような表を目にしたとき，char型は文字を表すのに，どうして－128～127って書いてあるの？ と思いました。誰でも最初は素人なのです。

![](http://panzhifei.fun/img/2021/03/31/01/hyo01.jpg)
*表1●C言語の主な変数の型と，表現できる値の範囲*

前回，説明しましたように，コンピュータではプログラムもデータも，すべてオンとオフの2値の情報として，2進数のイメージで情報を扱います。メモリーの中に0と1がびっしり埋まっている様子を想像してください。2進数はご存じですよね。2で桁上がりする数のことです。例えば日頃使っている10進数の0，1，2，3，4を2進数で表すと0，1，10，11，100となります。この0と1の並びをどんどん，ながーく伸ばしていけば大きな値も扱えることに疑問の余地はありません[＊1](#jump1)。

コンピュータは，数値に限らず，文字も，音声も，画像も，2進数の0と1の並びで情報を扱います。コンピュータが生まれた国のアルファベットはもちろん，ひらがなも，漢字も，あらゆる文字も0と1の組み合わせで表現します。

　複数のコンピュータで互いに情報をやりとりするためには，どの文字を，どの0と1の組み合わせで表現するかをあらかじめ決めておかなければいけません。この決まりを「文字コード」といいます。

　もっとも代表的な文字コードは，ANSI（米国規格協会）が1962年に制定したASCII（アスキー）コードです[＊2](#jump2)。ASCIIコードでは，例えば1000001という7ビットの並び（16進数では41[＊3](#jump3)）がAを表し，1100001（16進数では61）はaを意味します。「1」という“文字”は0110001（16進数では31）です。表2のように，A，Bなどの可読文字だけではなく，NULやSOHなどの制御文字[＊4](#jump4)を含め128のコードが制定されています。

![](http://panzhifei.fun/img/2021/03/31/01/hyo02.jpg)
*表2●ASCIIコード表。例えば「A」は上位3ビットが4，下位4ビットが1なので，コードは16進数で41とわかる*

128種のコードなら7ビット，つまり1バイトで1ビットの余裕を持って表現できますよね。なので，C言語では文字は1バイトのchar型で表します。でも，漢字を含む日本語の文字は種類が多いので1バイトでは表現できません。WindowsではシフトJISコード，UNIX系OSではEUCコードなどの2バイトのコードを使って漢字やかなを表現します。また，近年では，1バイトで表現可能な文字も，漢字と同様に2バイトを使って表すUnicode（ユニコード）も広く使用されています。

　説明ばかりで少し退屈してきましたね。プログラムを作って，C言語で文字を変数に代入したとき，どのように扱われているかを見てみましょう。リスト1は，変数に文字や値を代入し，様々な形で標準出力（ディスプレイ）に出力してみるプログラムです。

![](http://panzhifei.fun/img/2021/03/31/01/02list01.jpg)
*リスト1●変数に文字や値を代入し，様々な形で標準出力（ディスプレイ）に出力してみる*

実行結果は**図1**です。この実行結果とリスト1のコードを照らし合わせて，char型変数の中身をイメージしていきましょう。まず，リスト1の(1)でchar型の変数を四つ宣言しています。c1，c2，c3，c4という名前（識別子）で指し示すことができる1バイトの箱を，メモリーに四つ作成したと考えてください。なお，c1，c2という変数名には特に意味はありません。C言語では英字・数字・アンダースコア（_）の組み合わせを識別子として使用できます。変数に名前を付けるときは，「数字で始めることはできない」「大文字・小文字は区別される」「C言語の予約語（例えば，intやreturn）を使うことはできない」――などの規則があることを覚えておいてください。

![](http://panzhifei.fun/img/2021/03/31/01/02zu01.jpg)
*図1●リスト1の実行結果*

リスト1の(2)でc1に「A」という文字を代入しています。C言語では文字はシングルクォーテーション（'）で区切ります。このc1の値を画面に表示するコードは，すぐ下にある(3)のprintf関数です。printf関数は書式付きで文字列を出力します。同じ値を文字として出力したり，10進数，16進数で表示することができます。

　printf関数の第1引数には文字列を指定します。文字列は，複数の文字の並びのことで，文字とは違い，ダブルクォーテーション（"）で区切ります。文字列中の%c，%x，%dなどを変換仕様といい，第2，3，4引数がこの変換仕様の部分に展開されていきます。文字として出力するには%cを，16進数として出力したい場合は%xを，10進数の整数として出力する場合は%dを指定します。第2，3，4引数はどれもc1です。図1の実行結果を見ると，

**文字：A 16進数：41 10進数：65**

と表示されていますね。文字としては「A」なのですが，メモリー内部では16進数で41，つまり2進数で01000001というビットの並びで表現されていることがわかります。

　さて，printf文の第1引数で指定した文字列の中に，画面に表示されていない文字があります。「\n」です。\nは改行を意味する「エスケープ・シーケンス」です。エスケープ・シーケンスは，画面に表示できる文字だけで，制御文字を入力するための仕組みです。\nのように，「\」と「n」を続けて入力すると改行の制御文字を表すことができます。なのでリスト1の(3)の実行を終えたところで，1行改行しているわけです。なお，「\」という文字そのものを表したい場合は，「\\」と\を二つ続けて入力します。

　(4)の\x61も，2桁の16進数で61を表すエスケープ・シーケンスです。(5)で文字として表示させると，aと表示されます。(6)と(7)は文字としての「1」の表示です。文字の1は，16進数で31，2進数で00110001というビットの並びです。

　(8)と(9)は変数c4に代入した\nを文字として出力しています。図1を見ると，「\n」と表示される代わりに，行が変わっていますね。改行を意味する制御文字を表示しようとすると，画面では改行として扱われます。\nは16進数ではa，10進数では10と表示されています。2進数では00001010です。

## 足し算で小文字を大文字に変える

　一つの英数字が，メモリー上では2進数8桁で表されているというイメージをつかむことができたでしょうか。次に，キーボードから入力した英字の大文字を小文字に変換するプログラムを考えてみましょう。

　英字の大文字はA=41（16進）からZ=5A（16進）まで，順序よく並んでいます。小文字もa=61（16進）から，お行儀よく整列しています。char型の変数といっても中味は数値ですから，文字と文字を足し算したり，引き算したりと，お互いに計算させることができます。Aとaの数値としての差と，Zとzのそれに違いはないので，入力された大文字に'a'－'A'の値を足してやれば，小文字になるはずです。

　この仕組みをプログラムとして書いたのが**リスト2**です。(1)で宣言したchar型変数cに，(3)のscanf関数で文字を入力しています。

　**scanf("%c",&c);**

の「%c」はprintf関数に指定したものと同じ変換仕様です。標準入力（キーボード）から文字を1文字読み込みます。

![](http://panzhifei.fun/img/2021/03/31/01/02list02.jpg)
*リスト2●大文字を小文字に変換する*

第2引数にある「&c」の「&」はアドレス演算子といい，指定した変数のメモリー上の場所（アドレス）を取得します。変数のアドレスについては，今後の連載でじっくりと説明しますが，scanf関数は変数という一つの箱に値を入れるときに，変数の名前ではなく，“場所を教えてくれ”と要求する関数なのだと理解してください。ともかくこのように書くと，char型の変数cに文字を読み込むことができます。

　さて，aとAの差は，リスト2の(2)でint型（整数型）の変数diffに入れています。int型は4バイトで整数を記憶するデータ型です。整数値として差異を求めることが目的なので，char型ではなくint型を使用しています。(2)のように変数は宣言と同時に値を代入し，初期化することができます。(4)では，入力された文字にdiffを足して小文字に変換しています。

　実行結果は**図2**です。「J」が「j」に変換されていますね。なお，このサンプル・プログラムでは，入力された値のチェックを行っていません。実用的なプログラムにするには，入力値が英字大文字の範囲内にあるかどうかをチェックする必要があります。

![](http://panzhifei.fun/img/2021/03/31/01/02zu02.jpg)
*図2●リスト2の実行結果*

## コンピュータは小数点以下の計算が苦手？

　ここまでは，char型（文字型）とint型（整数型）の変数を使ってきました。それぞれunsignedと付いている型は符号なしで正の値のみを扱うための型です。各変数のサイズはコンパイラやOSの種類によって異なる場合がありますが，Borland C++コンパイラで作成したプログラムは，int型は4バイト，char型は1バイトのメモリー領域を使用します。

　整数型には収まらないような大きな値や，小数点以下の値を含む実数を扱うときに，C言語ではfloatやdoubleといった浮動小数点数型を使います。科学技術計算などでよく用いられ，実際とても便利なのですが，計算すると誤差が出る場合があり注意が必要です。

　サンプル・プログラムで見てみましょう（リスト3）。0.2をfloat型の変数に111回足して，その値が22.2と等しいかどうかを調べ，等しい場合は「0.2を111回足すと，22.2になります。」と表示するものです。

![](http://panzhifei.fun/img/2021/03/31/01/02list03s.jpg)
*リスト3●浮動小数点数型の変数に0.2を111回足して，結果が22.2になるかを試す*

リスト3を読むためには，「++」など，C言語特有の演算子と制御文を理解する必要があります。リスト3の内容に入る前に簡単に解説しておきましょう。リスト3の(2)で登場する「++」は，インクリメント演算子と呼びます。「i++」と書くと，iに1を加算します。Visual Basicなどでは単純にカウンタの値を1アップさせるときでも，i = i + 1と書かなくてはならないので，「C言語みたいにi++と書ければ良いのに」と筆者は面倒に感じます。減算はデクリメント演算子を使ってi--と書きます。

　なお，インクリメント演算子とデクリメント演算子は，++iのように変数の前に記述することもできます。変数を単純にインクリメント，デクリメントするだけなら，演算子を前に置く（前置）場合と後ろに置く場合（後置）に違いはありません。でも，式の中で使う場合は注意が必要です。

　例えば，aが0のとき，後置インクリメントで

　**b = a++;**

を行うと，aの値は1になりますがbの値は0です。

　**b = ++a;**

と前置にするとaとbの両方が1になります。後置では，bにaを代入してからaをインクリメントし，前置ではaをインクリメントしてからbに代入するという違いがあるのです。

　ほかに，C言語で利用する主な演算子を表3にまとめておいたので参照してください。制御文の書き方は，コードを追いながら解説しましょう。

![](http://panzhifei.fun/img/2021/03/31/01/02hyo03.jpg)
*表3●C言語の主な演算子*

というところで，リスト3の解説に入ります。(1)でfloat型の変数fを宣言すると同時に，0を代入して初期化を行っています。(2)のfor文が0.2を111回繰り返し加算する制御文です。forのカッコの中にある「i=0;i＜111;i++」は，iが0から111より小さい間，一つずつiの値を増やしながら繰り返しをする，という意味です。なので，iが0から110まで順番に，(3)の文を繰り返し実行します。

　(3)のf+=0.2もC言語の便利な書き方で，意味は上の行にコメント[＊5](#jump5)として記述してあるように，f = f + 0.2です。もちろんf = f + 0.2と書くこともできます。減算や掛算，割り算も同様に，－＝，＊＝，／＝と記述することができます。くだくだ書かなくてもよいところが，C言語がプログラマに好まれる理由の一つかもしれません。

0.2を111回足した値が22.2と等しいかどうかを判断しているのが(4)のif文です。if文は条件分岐を行う制御文です。この例ではelseとともに記述していますので，fが22.2と等しいとき(5)の文を実行，else(それ以外)のとき(6)を実行します。＝＝は等しいかどうか比較する演算子です。比較演算子はほかにも表3のように用意されています。

　さて，このプログラムの結果はどうなるでしょうか？ 意外かもしれませんが，「0.2を111回足しても，22.2になりません。」と表示されるのです（**図3**）。何度実行しても22.2にはなりません。「0.2を111回足せば，22.2に決まっているじゃないか！」と普通，思いますよね。でも浮動小数点数型の計算では，小さな違いが出てしまうのです。

![](http://panzhifei.fun/img/2021/03/31/01/02zu03.jpg.jpg)
*図3●リスト3の実行結果*

皆さんは，1÷3が割り切れず，0.3333…という「循環小数」になることはご存じですよね。0.3333…を3回足しても1にはなりませんね。一方，1÷2は0.5ぴったりの「有限小数」です。

　今回リスト3で利用した0.2は，私たちになじみの深い10進数では有限小数ですが，実はコンピュータにとっては循環小数なのです。コンピュータの中ではあらゆる情報が2進数で扱われています。10進数ではきりのよい数値が，2進数では扱いにくい数になることがあるのです。2進数になじみがないとイメージしにくいかもしれません。あわてず，ゆっくり考えていきましょう。

　10進数の9999は，10の0乗×9 ＋ 10の1乗×9 ＋ 10の2乗×9 ＋ 10の3乗×9と表すことができます。同様に，2進数の1011は2の0乗×1 ＋ 2の1乗×1 ＋ 2の2乗×0 ＋ 2の3乗×1と表すことができます。

　10進数では桁上がりすると，10倍，100倍…となっていきます。一方，2進数の場合は2倍，4倍…です。では，小数点以下はどうなるのかと言うと，10進数では，1/10，1/100…ですから，2進数では，1/2，1/4…と半分，半分になっていくのです。ここで，10進数の0.2を2進数で表すために2進数の各桁の値を足していくと，0.001100110011…と，0011を繰り返す循環小数になってしまいます。

　このように，10進数では有限小数だった数が，2進数では循環小数になってしまうことがあるのです。というわけで浮動小数点数型を使うときは，乱暴な言い方に聞こえるかもしれませんが，「近似値を求めるのだ」と最初から割り切っておくことが必要でしょう。金属の金は，フォーナイン（999.9）で純金ですし，工業や科学技術計算では許容できる誤差があります。例えば，このサンプル・プログラムの場合，完全に一致していなくても，22.2との差が0.0001未満なら一致していると判断してもいい場合があるのです。しかし，どうしても困る分野もあります。銀行の金利計算や為替の計算では，近似値というわけにはいきません。コンピュータの都合で，誰かが損をすると困ってしまいます。

　そのために，例えばVisual Basicには通貨型（Currency）が用意されていたり，データベースにもMoney型などの正確に金額を記憶するための型があるのです。また，事務処理分野で古くから利用されてきたCOBOL言語には，BCD（Binary Coded Decimal：2進化10進数）という形式があります。BCDでは10進数の0から9までを，4桁の2進数で表現します。185は，1と8と5をそれぞれ，0001，1000，0101と表すことができます。これに小数点が何桁目の位置にあるかという情報があれば，人間と同じように10進数で計算することができるのです。

　では，そういうデータ型が用意されていないC言語ではどうすればよいのかと言うと，計算は整数で行い，計算結果を小数点以下の値を含む値に戻すという方法が考えられます。0.2を111回足した結果を表示するのなら，2を111回足して，最後に10で割って答えを出すようにすればいいのです。

# <span id="title3">第3回　制御構文がわかればプログラムの「流れ」がわかる</span>

<center>☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆</center>
<center><span id="title13">☆　　　　　コメント　　　　　☆</span></center>
<center>☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆☆</center>

<span id="jump1">＊1 母国語は機械語（マシン語）</span>
英語と日本語の差ほどではないのですが，コンピュータやOSによって，マシン語にも違いがあります。例えば，Windows用のマシン語プログラムをUNIXマシンに持っていっても，そのまま実行させることはできません。

<span id="jump2">＊2 マシン語プログラムを16進数で</span>
2進数は，1桁で0と1の2値を表現できますが，マシン語などのダンプ表示に2進数を使うと，0と1がずらずらと並んでわかりにくくなります。そこで一般には2進数となじみのよい16進数で表記します。16進数1桁で2進数4桁を表現できます。

<span id="jump3">＊3 自然言語</span>
自然言語は，日本語や英語のように，人間が自然に使い出した言語のことです。

<span id="jump4">＊4 バグ</span>
バグはコンピュータのプログラムに含まれる誤り，欠陥のことです。

<span id="jump5">＊5 Java VM</span>
Java VMはJava Virtual Machine の略で，Javaの中間コードをマシン語に変換して実行するためのソフトウエアです。

<span id="jump6">＊6 .NET Framework</span>
.NET Frameworkは，Microsoft .NET対応アプリケーションの動作環境です。.NET Framework用の中間コードにコンパイルされたコードを，.NETFrameworkがOSごとのマシン語に変換して動かします。JavaVMとの違いは特定の開発言語に依存しないことです。米Microsoftが提供する主要な開発言語であるVisual Basic/C++/C#などのほか，Borland Delphi 8でも.NETFramework対応のプログラムを作成できます。

<span id="jump7">＊7 Windows 98におけるインストール</span>
Windows 98におけるインストールについては，日経ソフトウエアの[Webサイト](http://software.nikkeibp.co.jp/software/special/bcc_install/bcc_install.html)のWebスペシャルの情報などを参考にしてください。

<span id="jump7">＊8 src</span>
srcはsource（ソース）の略で，一般にソース・プログラムを格納するフォルダ名として利用されます。
